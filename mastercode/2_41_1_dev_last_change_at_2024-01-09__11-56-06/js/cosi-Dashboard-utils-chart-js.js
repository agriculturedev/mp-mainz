(window.webpackJsonp=window.webpackJsonp||[]).push([[276,259],{3671:function(y,J){var b=Object.defineProperty,w=Object.getOwnPropertyDescriptor,h=Object.getOwnPropertyNames,j=Object.prototype.hasOwnProperty,D=(p,s)=>{for(var o in s)b(p,o,{get:s[o],enumerable:!0})},P=(p,s,o,c)=>{if(s&&typeof s=="object"||typeof s=="function")for(let n of h(s))!j.call(p,n)&&n!==o&&b(p,n,{get:()=>s[n],enumerable:!(c=w(s,n))||c.enumerable});return p},C=p=>P(b({},"__esModule",{value:!0}),p),_={};D(_,{default:()=>f}),y.exports=C(_);class f{constructor({id:s="cg",name:o,data:c,type:n,beginAtZero:m=!1,stacked:x=!1,scaleLabels:d,color:g="blue",source:v="",sub:L=!1,sub_graph:F,sub_index:e,sub_length:t,options:r}){if(!(o&&c&&n&&typeof o=="string"&&(typeof n=="string"||Array.isArray(n))&&typeof c=="object"))throw new EvalError(`ChartDataset: 'name', 'data' and 'type' musst be provided in the options. Got ${o}, ${c} and ${n} instead`);this.type=n,this.id=s,this.name=o,this.color=g,this.data=c,this.scaleLabels=d,this.source=v,this.source=v,this.beginAtZero=m,this.stacked=x,this.sub=L,this.sub_graph=F,this.sub_index=e,this.sub_length=t,this.options=r,this.cgid=s+"-"+o}}},3930:function(y,J,b){var w=Object.create,h=Object.defineProperty,j=Object.getOwnPropertyDescriptor,D=Object.getOwnPropertyNames,P=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty,_=(e,t)=>{for(var r in t)h(e,r,{get:t[r],enumerable:!0})},f=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of D(t))!C.call(e,a)&&a!==r&&h(e,a,{get:()=>t[a],enumerable:!(i=j(t,a))||i.enumerable});return e},p=(e,t,r)=>(r=e!=null?w(P(e)):{},f(t||!e||!e.__esModule?h(r,"default",{value:e,enumerable:!0}):r,e)),s=e=>f(h({},"__esModule",{value:!0}),e),o={};_(o,{generateChartForCorrelation:()=>L,generateChartForDistricts:()=>v,generateChartsForItems:()=>F,generateGraphObj:()=>d,generateScatterGraphObj:()=>g}),y.exports=s(o);var c=p(b(3671));function n(e,t,r,i){const a=e[t.value],l={label:t.text,data:[]};for(const u of r)l.data.push(a?.[i+u]);return l.data.reverse(),l}function m(e){const t={};for(const r of e)t[r.district]?t[r.district].data.push(r):t[r.district]={label:r.district,data:[r]};return Object.values(t)}function x(e){return{type:"line",label:"Regression",data:e.data.map(t=>({x:t.x,y:t.yEst})),correlation:e.correlation,covariance:e.covariance,options:{showLine:!0}}}function d(e,t,r,i){return new c.default({id:"ccm",name:t+" - "+r,type:["LineChart","BarChart","PieChart"],color:"rainbow",source:"Dashboard",scaleLabels:[r,"Jahre"],data:{labels:[...i].reverse(),datasets:e}})}function g(e,t,r){return new c.default({id:"ccm",name:`${r} / ${t}`,type:"ScatterChart",color:"rainbow",source:"Dashboard",scaleLabels:[r,t],data:{datasets:e}})}function v(e,t,r,i="jahr_"){const a=t.map(u=>n(e,u,e.years,i));return d(a,r,e.category,e.years)}function L(e,t,r){const i=m(e.data),a=x(e);return g([...i,a],t,r)}function F(e,t,r,i="jahr_"){const a=[...new Set(e.reduce((u,S)=>[...u,...S.years],[]))].sort();return t.map(u=>{const S={labels:a,datasets:e.map(O=>({label:O.category,data:a.map(k=>{var G;return parseFloat((G=O[u.value])==null?void 0:G[i+k])})}))};return new c.default({id:"ccm-"+e.map(O=>O.category).join(","),name:(u.districtLevel||r)+" - "+u.text,type:["LineChart","BarChart"],color:"rainbow",source:"Dashboard",scaleLabels:["","Jahre"],data:S})})}}}]);
